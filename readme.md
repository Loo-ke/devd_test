# debounce 함수 테스트 케이스

## 케이스 1

- 설명 : 클릭 이벤트가 연속으로 발생하는 경우를 테스트합니다.
- 실행 방법 : 클릭 버튼을 빠르게 여러 번 클릭합니다.
- 결과 : 클릭 시 즉시 clickCount가 올라가고, 마지막 클릭 이벤트의 wait 시간이 흐른 뒤 debounce 카운트가 올라갑니다.

## 케이스 2

- 설명 : 클릭 버튼을 누른 직후 다른 이벤트 실행하는 경우를 테스트합니다.
- 실행 방법 : 클릭 버튼 누른 직후 wait 시간이 흐르기 전에 immediate 버튼을 클릭합니다.
- 결과 : 클릭 버튼을 눌렀을때의 함수는 취소하고 즉시 디바운스가 실행되고 debounce 카운트가 올라갑니다.

## 케이스 3

- 설명 : 클릭 이벤트 직후 취소 이벤트를 테스트합니다.
- 실행 방법 : 클릭 이벤트 직후 취소 버튼을 클릭합니다.
- 결과 : debounce 카운트가 올라가지 않고 함수는 취소가 됩니다.

## 트러블 슈팅

- 설명 : immediate 버튼을 누르면 promise가 완료되지 않은 현상을 발견했습니다. 그 결과 즉시 버튼을 페이지 접속 후 최초로 누르면 console.log("즉시 디바운스")가 출력이 안되는 상황을 발견했습니다.
- 방법 : `if(immediate){...}` 코드를 `if(!promise){...}` 다음으로 순서를 바꿨습니다.
- 결과 : immediate 버튼을 눌렀을 시 `if(immediate){...}` 실행 전 promise에 값을 할당해 정상적으로 setPromise() 함수가 실행되며 promise가 resolve가 되어 then 이하의 함수가 실행되게 설정하였습니다.

## 면접 현장 추가사항

- 설명 : wait 시간 이후에 어떤 이유로 debounce가 실행이 되지 않았을 시 maxWait을 이용해 지정된 시간 이후에 debounce가 실행되지 않으면 무조건 실행하는 코드 작성
- 방법 : maxWait을 인자로 받아 setTimeout을 새로 설정하고 if문을 이용해 later함수가 실행되지 않으면 실행
- 아쉬운점 : maxWait을 인자로 받아 사용한다는 것 까지는 좋았지만, 너무 긴장한 나머지 세번째 setTimeout에 사용한다고 말해서 애매한 답변이 되었습니다.
